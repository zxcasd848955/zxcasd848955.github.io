[{"categories":["idol"],"contents":"不急不躁，\n十年蛰伏。\n云上看景，\n未来可期。\n演员朱一龙\r\r\r\r\r\r\r\r\r\r","permalink":"https://zxcasd848955.github.io/life/d2/","tags":null,"title":"演员就要有演员的样子"},{"categories":["PS"],"contents":"开始学PS了 虽然以前收集了很多资料，但是毛用都没有。:(\n","permalink":"https://zxcasd848955.github.io/blog/post-3/","tags":[""],"title":"PS"},{"categories":["PS"],"contents":"放送美图 太好看了吧 :)\n","permalink":"https://zxcasd848955.github.io/blog/post-4/","tags":[""],"title":"数据可视化"},{"categories":["travel"],"contents":"模把信息当作知识， 莫把收藏当学习。 莫把阅读当作思考， 莫把储存当作掌握。\n","permalink":"https://zxcasd848955.github.io/life/d1/","tags":["test"],"title":"day 1"},{"categories":["Visualization"],"contents":"数据可视化 简介  图形语法包含了数学风格的语法与美学风格的语法。 从图到图形接住了美学或者视觉上的一些属性，如大小和颜色。  定义或者描述  数据：数据可视化基于的数据源。 转化：对数据的一些转化操作，如聚合、排序、筛选等。 标度：缩放操作，如log。 坐标：坐标系统，如极坐标系、笛卡尔坐标系。 元素：图形的视觉元素与属性，如颜色、大小、形状。 指引/提示：提示信息，如刻度、图例。  流程  分析数据，对原始数据进行标准化，结构化。查看视角,主题提炼   元数据，维度，元数据间关系，数据规模\n  把数据转化为视觉结构(形状 位置 尺寸 方向 色彩 纹理等) 优化图形 检查测试，可读性优化  图形库  ggplot antv/G2 three.js D3.js  酷炫的图表 大数据网络安全可视化 ","permalink":"https://zxcasd848955.github.io/blog/post-2/","tags":[""],"title":"数据可视化"},{"categories":null,"contents":"不管你信不信，这个世界无论多么喧哗，一定有人还在专注地、默默地做着自己喜爱的东西。做一件细致入微的事情，安静生活、寂静思考。\n","permalink":"https://zxcasd848955.github.io/blog/post-1/","tags":null,"title":"产品，设计和技术"},{"categories":["Programming"],"contents":"SQL数据库结构  基本表是实际存储于存储文件中的表\n视图是由基本表产生的映像信息，数据动态产生于维护。视图的更改最终体现在基本表的更改上。\n 定义视图  create view view_name[(列名[, 列名] \u0026hellip;)]\nas 子查询 [with check option]\nwith check option 指明对视图进行insert, update, delete时要检查元组是否满足子查询中定义的条件表达式\n create View Teacher As (select T.Tname, C.Cname, Credit from Teacher T, Course C where T.T# = C.T#); //视图更新 create View S_G(S#, Savg) as (select S#, AVG(Score) from SC group by S#); update S_G set Savg = 85 where S# = \u0026#39;98030101\u0026#39;//不能更新 视图不能更新的几种情况   视图的select目标列包含聚集函数 视图的select子句使用了unique或distinct 视图中包括了group by子句 视图中包括经算数表达式计算出来的列 视图由单个表的列构成，但并没有包括主键   数据库完整性   广义完整性: 语义完整性，并发控制，安全控制，DB故障恢复等 侠义完整性:专只语义完整性 关系模型中有完整性约束:实体完整性, 参照完整性,用户自定义完整性   静态约束(列完整性(域)，表完整性(关系完整性))  Integrity Constraint ::=(O, P, A,R)\nQ:数据集合：约束的对象。列，多列(元组)，元组集合\np:谓词条件：什么样的约束\nA:触发条件：什么时候检查\nR:响应动作：不满足时怎么办\n Create Table tablename ({collname datatype [Default {default_constant | null}] [col_constr {col_constr...s}] | table_constr }, {collname datatype [Default {default_constant | null}] [col_constr {col_constr...s}] | table_constr });  col_constr列约束\n一种列约束，对单一列的值进行约束\n{Not null | [Constraint constraintname] {Unique |Primary key |Check (search_cond) |References tablename [(colname)] [on delete {cascade | set null}]} }   table_constr表约束\n一种关系约束，对多列或元组的值进行约束\n[Constraint constraintname] {Unique (colname{, colname..}) |Primary key(colname{, colname..}) |Check (search_condition) |Foreign key(colname{, colname...}) References tablename [(colname{, colname...})] [on delete cascade] }   修改表\nAlter table tbname [Add ({colname datatype...})] [Drop ...] [Modify...] [Add Constraint constr_name] [Drop Constraint constr_name] [Drop Primary key]  断言ASSERTION  当断言创建后，系统会检测其有效性，并在每一次更新中测试更新是否合理。\n断言增加了数据库维护的负担。\n Create ASSERTION \u0026lt;assertion_name\u0026gt; check \u0026lt;predicate\u0026gt;  实例\n\u0026ldquo;每笔贷款，要求至少一位借款者账户中由最低数目的余额 如1000\u0026rdquo;\n create assertion balance_constraint check (not exists( select * from loan where not exists( select * from borrower, depositor, account where loan.loan_number = borrower.loan_number and borrower.customer_name = depositor.customer_name and depositor.account_number = account.account_number and account.balance \u0026gt;= 1000 ) )) 动态约束(触发器)  Integrity Constraint ::= (O, P, A, R)*\n基本语法\n条件或程序段中引用的变量可用corr_name_def来限定\n Create Trigger trigger_name BEFORE | AFTER {Insert | Delete | Update [OF colname {, colname...}] } ON tablename [Referencing corr_name_def {, corr_name_def...}] [FOR EACH ROW | FOR EACH STATEMENT] [WHEN (search_condition)] //检查条件 {statement //单行程序直接书写，多行如下 | BEGIN ATOMIC statement; {statement; ...} END} 实例\n 1.更新Teacher表时工资只升不降\n create trigger teacher_chgsal before update of salary on teacher referencing new x, old y for each row when(x.salary \u0026lt; y.salary) begin raise_appllication_error(-2000, \u0026#34;invalid salary on update\u0026#34;);// oracle end  2.当删除某一个同学S#时，该同学的所有选课要删除\n create trigger dels# after delete on Student referencing old oldi for each row begin delete sc where S# = :oldi.S#; end;  3.Dean 一定时该教师Teacher 中工资最高的教师\n create trigger upddean before update of Dean on Dept referencing old oldi, new newi for each row when (dean not in select Tname from Teacher where D# = :newi.D# and salary \u0026gt;= all(select salary from Teacher where D# = :newi.D#)) begin raise...; end; 数据库安全性  物理控制， 网络控制， 操作系统控制， DBMS控制\n DBMS安全机制  自主安全性机制：存取控制 强制安全性机制 推断控制机制 数据加密存储机制  自主安全性机制 概览 AccessRule ::= (S, O, t, P)\n S 请求主体：可按用户组 O 访问对象：属性/字段， 记录/元， 组， 关系， 数据库 t访问权力：创建，增， 删， 改， 查 P谓词：条件 通常存储在数据字典或者系统目录中  实现方式  存储矩阵 视图  DDL操作  形式为：alter table tablename\n[add {colname datatype, \u0026hellip;}]\n[drop {完整性约束名}]\n[modify {colname datatype, \u0026hellip;}]\n alter table Student Add Saddr char[40], PID char[18]; alter table Student Modify Sname char(10); alter table Student Drop Unique(Sname); SQL-DCL //授权 Grant {all Privileges | privilege {,privilege...}} on [table] tablename | viewname to {public | user-id {, user-id...}} [with grant option] //收回授权 Revoke {all Privileges | priv {, priv...}} on tablename | viewname from {public | user {, user...}} 强制安全性 绝密TS, 机密S, 可信C, 无分类U\n实现方式   关系模式: R(A1: D1, A2: D2, ..., An:Dn)\n  对属性和元组引入安全性分级特性或称分类特性R(A1: D1,C1, A2: D2, C2,..., An:Dn, Cn, TC)C1, C2\u0026hellip;为安全属性\nTC为元组的分类特性 TC, C: S, U, C, TS\n  数据库查询实现算法 数据库三大类操作  一次单一元组的一元操作 Selection, Projection 迭代器算法 整个关系的一元操作 Distinct, Group by, Sorting （ 一趟扫描 ，两趟扫描， 多趟扫描） ====\u0026gt; (基于排序，基于散列， 基于索引) 整个关系的二元操作 集合的操作, 包上的操作, Product, Join  连接操作 P1基本实现 //三个内存页 for i = 1 to B_r read i-th block of R; for j = 1 to B_s read j-th block of S; for p = 1 to b/I_r read p-th record of R; for q = 1 to b/I_s read q-th record of S; (串接p-th record of R and q-th record of S) Next q Next p Next j Next i P2全主存实现 for i = 1 to B_r//有可能连续读入多块 read i-th block of R; Next i for j = 1 to B_s read j-th block of S; Next j for p = 1 to b/I_r read p-th record of R; for q = 1 to b/I_s read q-th record of S; (串接p-th record of R and q-th record of S) Next q Next p P3半主存实现 for i = 1 to B_r//有可能连续读入多块 read i-th block of R; Next i for j = 1 to B_s read j-th block of S; for p = 1 to b/I_r read p-th record of R; for q = 1 to b/I_s read q-th record of S; (串接p-th record of R and q-th record of S) Next q Next p Next j P4大关系实现 for i = 1 to B_s / (M - 2) //一次读入M-2块 \tread i-th Sub-set of S into M_s; for j = 1 to B_r //一次读入一块  read j-th block of R into M_r; for p = 1 to (M - 2) / I_s read p-th record of S; for q = 1 to b/I_r read q-th record of R; (串接p-th record of R and q-th record of S, 存入结果关系) Next q Next p Next j Next i 连接操作的物理实现 表空间扫描算法  基本实现：3块内存 B_r + B_r * B_s 任何情况 全主存：B_r + B_s 半主存：B_r + B_s 大关系：任何情况，尤其大关系 B_r*(B_s / (M - 2)) + B_s  归并排序连接算法 散列连接 索引连接 查询实现的两种策略  物化计算策略 流水线计算策略  一趟扫描算法 建立内存数据结构，以快速定位一个元组如排序结构，散列结构， B+树\n 去重 分组聚集 集合操作，包操作  基于索引的选择算法 聚簇索引与非聚簇索引性能差别很大\nZig-Zag算法基于B+树索引\n两趟扫描算法  Step one划分子集，并使子集具有某种特性，如有序或相同散列值 Step two处理全局性内容的操作，形成结果关系。如多子集间的归并排序，相同散列值子集的操作等  两阶段多路归并TPMMS  子集合数 \u0026lt; B_memory\n子集合的块数 \u0026lt; B_memory\n大数据集块数 \u0026lt; B_memory\n基本思想如下\n  N个子集合各自依次读取一块装入内存。 内存中的N块(对应于N个子集合)各自依次读取一个元素形成一个待比较集合。 将待比较集合中的最小的元素取出输入到块中。 输出块依序写回磁盘上。   对于大数据集：多趟/多阶段\n  Distinct 1.划分子表，并排序。2.排序基础上，将重复的记录直接删除 Group by 1.划分子表，并排序。2.排序基础上，将不重复的记录作为新分组输出；将重复的记录进行分组聚集计算 并集合上的并需两趟去重，包上的并一趟 交都需要两趟，处理出现次数或者去重。对于集合交：t在R和S都出现输出；对于包交：输出的次数时在R和S中出现的最小次数 差两趟，对于集合差：当且仅当t在R中出现但不在S中出现输出；对于包差：输出次数是在R中的次数减去在S中的次数  基于排序的连接操作  Step one划分R和S的子表并进行排序，排序基于某个属性 Step two归并时注意是R的输入还是S的输入。R和S的两路输入之间进行连接检查并连接之后输出 \u0026ldquo;排序-连接\u0026rdquo;， \u0026ldquo;归并-连接\u0026rdquo;， \u0026ldquo;排序-归并-连接\u0026rdquo;  基于散列的两趟扫描算法  Step one大数据集可以转换为某个子集的操作。散列子表，用散列函数将原始关系分成M-1个子表，并存储。 Step two处理每个子表，用另一个散列函数将子表读入内存并建立内存结构，进行不同操作的处理。  各种操作的实现\n Distinct 1.原始关系散列成M-1个子表并存储，2.处理每个子表，并读入内存，用另一个散列函数形成散列结构，并进行去重。 Group by1.原始关系散列成M-1个子表并存储， 2.处理每个子表，并读入内存，用另一个散列函数形成散列结构，并进行分组聚集操作。 并1.使用相同散列函数散列两个操作对象R和S，形成R_1\u0026hellip;.R_m，和S_1\u0026hellip;.S_m。2.对于集合，直接合并；对于包，第一趟：散列R和S形成M-2个子表R_i, S_i；第二趟：将S_i整体散列读入内存，再依次处理R_i的每一块。若t出现在R_i和S_i中，仅输出t的一个副本，否则输出R_i和S_i 交同上  基于散列的连接操作  Step one 以连接属性Y为散列关键字，设计散列函数 Step two使用相同散列函数散列两个操作对象R和S，形成R_1\u0026hellip;.R_m，和S_1\u0026hellip;.S_m Step three 将S_i整体散列读入内存，再依次处理R_i的每一块，进行连接。  数据库查询优化 概览  语义优化：利用模型的语义及完整性规则, 去掉多余的属性。 语法优化：逻辑层：利用语法结构优化执行操作次序, 尽可能早的选择和投影运算。 执行优化：存取路径和执行算法的选择与执行次序优化, 代价最小的例行程序。  存储管理器 \u0026lt;\u0026mdash;\u0026ndash;\u0026gt; 缓冲区管理器-\u0026lt;\u0026mdash;\u0026mdash;\u0026gt;索引/文件和记录管理器\u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;基本关系/操作实现/算法集合\n控制磁盘读写\u0026lt;\u0026mdash;\u0026mdash;-\u0026gt;控制内存分配，内存块/磁盘块交换\u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;控制逻辑/物理映射\u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-被选择被组合被调用执行\n逻辑查询优化 关系代数层次优化，用语法树来表达关系表达式。\n策略\n 把选择和投影串接起来：一元序列可一起执行 把投影与其前或后的二元运算结合起来：去除多余属性 把某些连接与其前的笛卡尔积合并成一个连接：当R x S前有选择且其中有条件是R, S属性间比较，将其转化为连接 执行连接运算前对关系适当预处理：文件排序，建立临时索引等 找出表达式里的公共子表达式：若表达式结果不大，可预先计算，以后读入此结果。  关系代数交换\n 连接与连接交换，积与积交换。并运算和交运算也可。 选择结果集合小的表达式先装入内存 连接与连接，积与积的结合律。并运算和交运算也可。选择结果集合小的表达式先计算 投影串接律。 选择串接律。 选择和投影交换律。 选择和积的交换律。 投影和积的交换律。 选择和并的交换律。 选择和差的交换律。 投影和并的交换律。  对语法树进行分组\n每个二元运算节点(积， 并，差，连接等)和其所有一元运算直接祖先节点放在一组；对于其后后代节点，若后代节点是一串一元运算且以树叶为终点，则将这些一元运算节点放在该组中；若该二元运算节点是笛卡尔积，且其后代节点不能和它组合成等连接，则不能将其后代节点归入该组。\n物理查询优化 物理查询运算符\n 获取关系元组的操作 表空间扫描算法，表空间扫描排序算法，索引扫描算法，索引扫描排序算法， 关系操作的各种实现算法 一趟，两趟算法；基于索引算法，基于散列算法，基于排序算法 迭代器构造\u0026ndash;流水线，物化  物理查询计划优劣的衡量\n I/O访问次数 CPU占用时间 内存使用代价(与缓冲区数目与大小的匹配) 中间结果存储代价 计算量(搜索记录，合并记录，排序记录，字段值的计算) 网络通信量  依据数据库统计信息，存放在数据字典或系统目录中，来对各种物理查询计划进行评估\n如IBM DB2使用Runstats收集统计信息，Oracle使用Analyze命令收集统计信息并放入系统表中\n数据库事务/并发控制 三种典型的不一致现象  丢失修改：A被修改2次，但后一次修改覆盖了前一次修改，从而丢失A的累积修改结果 不能重复读：两次读的不是同一数据 脏读：事务撤销导致的数据读错误  事务\n 宏观性：应用程序员看到的：一条或多条SQL语句的一次执行 微观性：对数据库的一系列基本操作(读，写)的一个整体性执行  事务宏观独立完整，微观交错执行(通过并发控制保证次序)\n事务调度：一组事务的基本步(读，写，其他控制操作如加锁，解锁等)的一种执行顺序称为对这组事务的一个调度\n并发调度的正确性：当且仅当这个并发调度下的新数据库结果与分别串行运行这些事务所得数据库结果是一致的\n可串行性：如果不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则说调度是可串行化的。\nNote：并行调度的正确性是指内容上结果正确性，而可串行性是形式上结果正确性。\n冲突：调度中一堆连续的动作，若它们顺序交换，那么涉及的事务中至少有一个事务行为会改变\n 同一事务的任何两种操作都是冲突的 不同事务对同一元素的两个写操作是冲突的 不同事务对同一元素的一读一写操作是冲突的  冲突可串行性：一个调度，若通过交换相邻两个无冲突的操作能转换到某一个串行的调度，则为冲突可串行化的调度\n基于封锁的并发控制 锁的类型\n 排他锁X：只有一个事务能读能写 共享锁S：所有事务都可读，都不能写 更新锁U：初始读，以后可升级为写 增量锁I：增量更新(A = A + X)  锁协议的相容性矩阵\n加锁/解锁的时机\n 0级协议：有写要求的数据对象A加排他锁，不再访问后即刻解锁，可防止丢失修改，但允许脏读，允许重复读错误。 1级协议：有写要求的数据对象A加排他锁，事务提交时刻解锁，可防止丢失修改，可恢复，防止脏读，允许重复读错误 2级协议：有写要求的数据对象A加排他锁，事务提交时刻解锁，有读要求的数据对象B加共享锁，不再访问后即刻解锁。可防止丢失修改，防止脏读，不允许重复读错误 3级协议：有写要求的数据对象A加排他锁，事务提交时刻解锁，有读要求的数据对象B加共享锁,事务提交后即刻解锁。防止有不一致性(如幻读，事务不能串行化，可增加范围锁或者表锁)  SQL之隔离性级别\n读未提交：相当于0级协议\n读已提交：相当于1级协议\n可重复读：相当于2级协议\n可串行化：相当于3级协议\n封锁粒度\n属性值 \u0026mdash;\u0026gt; 元组 \u0026mdash;-\u0026gt; 元组集合\u0026mdash;-\u0026gt;整个关系\u0026mdash;\u0026ndash;\u0026gt;整个DB某索引项\u0026mdash;\u0026ndash;\u0026gt;整个索引。并发度大，封锁开销也大\n两段封锁协议\n读写数据之前要获得锁，每个事务中所有封锁请求优先于任何解锁请求。加锁段不能有解锁操作，解锁段不能有加锁操作。\n可能产生死锁\n基于时间戳的并发控制 时间戳：唯一性和递增性\n时间戳小先执行，执行时间判断冲突，如无冲突，予以执行，有冲突则撤销事务，并重启该事务\n托马斯写规则：过时的写操作可直接被忽略掉，而无需撤销过时的事务\n基于有效性确认的并发控制 事务启动时被赋予唯一时间戳，美意事务读写数据集合RS(T), WS(T)\n读阶段：事务从数据库读取集合中的所有元素。事务还在其局部地址空间计算它将要写的所有值\n有效性确认调度器比较该事务与其他事务的读写集合来确认该事务的有效性\n写阶段：事务王数据库写入其写集合中元素的值\n数据库故障恢复 事务故障：某个程序(事务)自身运行错误，影响该程序(事务)本身\n系统故障：由于掉电，非正常关机等引起的错误，影响正在运行的事务以及数据库缓冲区，数据库缓冲区涉及正在运行和已运行的事务\n介质故障：由于介质损坏，影响是全面的，既影响内存中的数据，有影响介质中存储的数据\n故障恢复 事务故障恢复\n重做事务或者撤销事务\n系统故障恢复\n运行日志的事务操作顺序重做事务(当事务在发生故障时已正确结束)或撤销事务(当事务在发生故障时未结束)\n在运行日志中定期设置和更新检查点：是指DBMS强制内存DB Buffer中的内容与介质DB的内容保持一致，即将DB Buffer的所有内容写回DB\n介质故障恢复\n副本：某一时刻，对数据库在其他介质存储上产生的另一份等同记录。副本替换损坏的数据库，还需要运行日志进行恢复。\n转储点：备份时刻，\n缓冲区处理策略\n Force：内存中的数据最晚在commit时写入磁盘 No steal：不允许在事务commit之前把内存中的数据写入磁盘 No force：内存中的数据可以一直保留在commit之后过一段时间再写入磁盘(此时在系统崩溃的时候可能没写入磁盘，需要Redo) Steal：允许在事务commit之前把内存中的数据写入磁盘(此时若系统在commit之前崩溃时，已有数据写入磁盘，要恢复到崩溃之前的状态需要Undo)  最常用的是Steal + No force最快\n日志\nUndo：故障时未提交的事务\nRedo：故障时已提交的事务\nUndo/Redo\nUndo型日志\n记录规则：首先，\u0026lt;T, X, v\u0026gt;被写入到日志中；其次，OUTPUT(X)；最后，或者被写入到日志中。仅保留旧值。\n利用Undo型日志恢复\n 确定一个事务是否已完成 从日志尾部开始按日志记录的反序处理每一日志记录，撤销未完成事务的所有修改  Redo型日志\n记录规则：首先，\u0026lt;T, X, v\u0026gt;被写入到日志中；其次，被写入到日志中；最后，OUTPUT(X)。仅保留新值。\n利用Redo型日志恢复\n 确定一个事务是否已完成 从日志起始位置开始按日志记录的正序处理每一日志记录，重做已提交事务的所有修改  Undo/Redo型日志\n记录规则：(1)，\u0026lt;T, X, u, v\u0026gt;被写入到日志中；(2)或者(3)，被写入到日志中；(3)或者(2)，OUTPUT(X)。既保留旧值又保留新值。\n利用Undo/Redo型日志恢复\n 确定一个事务是否已完成 从日志起始位置开始按日志记录的正序处理每一日志记录，重做已提交事务的所有修改；从日志尾部开始按日志记录的反序处理每一日志记录，撤销未完成事务的所有修改。  ","permalink":"https://zxcasd848955.github.io/blog/post-5/","tags":["SQL"],"title":"About SQL"},{"categories":["Programming"],"contents":"删除Delete  删除有四门课程不及格的同学\nDelete from student Where `S#` in (Select `S#` from sc where Score \u0026lt;90 Group by `S#` Having Count(*) \u0026gt;= 1);  更新Update  Update SC set Score = Score*0.5 where C# = \u0026#39;001\u0026#39; and Score \u0026lt; some (Select AVG(Score) from SC where C# = \u0026#39;001\u0026#39;); 将张三同学001号课的成绩置为其班级该门课的平均成绩\nUpdate SC Set Score = (Select AVG(SC2.Score) from SC SC1, Student S1, SC SC2, Student S2 where S1.Sclass = S2.Sclass and SC1.S# = S1.S# and SC2.S# = S2.S# and S1.Sname = \u0026#39;张三\u0026#39; and SC1.C# = \u0026#39;001\u0026#39; and SC1.C# = SC2.C#) where C# = \u0026#39;001\u0026#39; and S# in (Select S# from Student where Sname = \u0026#39;张三\u0026#39;);  复杂SQL 非相关子查询与相关子查询  列出没学过李明老师讲授课程的所有同学的姓名\nSelect Sname from Student where S# not in (Select S# from SC, Course C, Teacher T where T.Tname = \u0026#39;李明\u0026#39; and SC.C# = C.C# and T.T# = C.T#);  theta some/ theta all子查询  基本语法: 表达式 theta some(子查询) ; 表达式 theta all(子查询)\ntheta有 \u0026lt;, \u0026gt;, \u0026gt;=, \u0026lt;=, =, \u0026lt;\u0026gt;\n找出工资最低的教师姓名\nSelect Tname from Teacher where Salary \u0026lt;= all(Select Salary from Teacher); 找出001课程成绩不是最高的所有学生的学号\nSelect S# from SC where C# = \u0026#39;001\u0026#39; and Score \u0026lt; some(Select Score from SC where C# = \u0026#39;001\u0026#39;); 找出所有课程都不及格的学生的姓名\nSelect Sname from Student where 60 \u0026gt; all(Select Score from SC where S# = Student.S#);  in / not in子查询  表达式 not in(子查询) 不等于 表达式 \u0026lt;\u0026gt; some(子查询)\n与not in 等价的是 表达式\u0026lt;\u0026gt; all(子查询)\n (Not ) exists子查询  检索选修了赵三老师主讲课程的所以同学的姓名\nSelect Distinct Sname from Student where exists (Select * from SC, Course, Teacher where SC.C# = Course.C# and SC.S# = Stuent.S# and Course.T# = Teacher.T# and Tname = \u0026#39;赵三\u0026#39;); 可以不加not\nSelect Distinct Sname from Student, SC, Course, Teacher where SC.C# = Course.C# and SC.S# = Stuent.S# and Course.T# = Teacher.T# and Tname = \u0026#39;赵三\u0026#39;); not Exists的神操作\n检索学过001号教师主讲的所有课程的所有学生的姓名\nSelect Sname from Student where not exists\t//不存在 {Select * from Course //所有001教师主讲的课程 where Course.T# = \u0026#39;001\u0026#39; and not exists\t{Select * from SC //该同学没学过 where S# = Student.S# and C# = Course.C#}}; 列出没学过李明老师讲授任何一门课程的所有同学的姓名\nSelect Sname from Student where not exists\t//不存在 {Select * from Course, SC, Teacher\t//学过一门课程 where Tname = \u0026#39;李明\u0026#39; and Course.T# = Teacher.T# and Course.C# = SC.C# and S# = Student.S#}; 列出至少学过98030101号同学学过的所有课程的同学的学号\nSelect Distinct S# from SC SC1 where not exists\t//不存在 {Select * from SC SC2\t//有一门课程 where SC2.S# = \u0026#39;98030101\u0026#39; and not exists\t//该同学没学过 {Select * from SC where c# = SC2.C# and S# = SC1.S#};  分组过滤Group by [Having 分组过滤条件]  Select S# from SC where Score \u0026lt; 60 Group by S# Having Count(*) \u0026gt; 2; 求有两门以上不及格课程同学的学号及其平均成绩\nSelect S#, Avg(Score) from sc where S# in {Select S# from SC where Score \u0026lt; 60 Group by S# Having Count(*) \u0026gt; 2} Group by S#  并-交-差 Union-Intersect-Except  子查询1 Union ALL 子查询2 结果出现m + n次\n子查询1 Intersect ALL 子查询2 结果出现min(m, n)次\n子查询1 Except ALL 子查询2 结果出现 max(0, m-n)次\n  求学过002号课的同学或者学过003号课程的同学学号\nSelect S# from SC where C# = \u0026#39;002\u0026#39; Union Select S# from SC where C# = \u0026#39;003\u0026#39;; 求既学过002号课有学过003号课的同学学号\nSelect S# from SC where C# = \u0026#39;002\u0026#39; Intersect Select S# from SC where C# = \u0026#39;003\u0026#39;; // or Select S# from SC where C# = \u0026#39;002\u0026#39; and S# in {Select S# from SC where C# = \u0026#39;003\u0026#39;};  内连接 外连接 [Inner | {Left | Right | Full}[Outer]] Join on 连接条件 Using Colname  求所有教师的任课情况并按教师号排序(没有任课的教师也需在列)\nSelect Teacher.T#, Tname, Cname from Teacher Inner join Course on Teacher.T# = Course.T# Order by Teacher.T# ASC; 求所有教师的任课情况(没有任课的教师也需在列)\nSelect Teacher.T#, Tname, Cname from Teacher Left Outer join Course on Teacher.T# = Course.T# Order by Teacher.T# ASC; ","permalink":"https://zxcasd848955.github.io/blog/post-8/","tags":["SQL"],"title":"SQl 语句及其优化"},{"categories":["Programming"],"contents":"以下链接均为转载，不是原创\n免费课程   阿里云官方   软件架构相关   如何架构合适的API网关 如何架构一个合适的企业API网关 企业级API网关的设计 百亿流量微服务网关的设计与实现 使用微服务架构思想，设计部署API代理网关和OAuth2.0授权认证框架 知乎：知乎架构 沈剑聊微服务：先做好你的服务拆分 如何理解统一数据访问层 API网关的重要性 如何用代理平台解决微服务的一些痛点 服务调用的演进历史 利用Mesos构建多任务调度系统 蚂蚁金服 Service Mesh 实践探索 腾讯云容器团队内部Istio专题分享 分布式追踪系统 分布式计算技术 海量分布式存储系统 Doris 的高可用架构设计分析   推荐系统   知乎：推荐系统入门要点哪些技能树？ 推荐系统产品与算法概述 | 深度  新浪微博：微博推荐架构演进 计算广告系统算法与架构综述 计算广告技术框架 今日头条推荐算法详解 今日头条核心技术细节是什么 文章如何实现大量曝光？今日头条：项亮 打造工业级推荐系统1：推荐算法工程师的成长之道 打造工业级推荐系统2：无处不在的推荐系统 打造工业级推荐系统3：推荐系统的工程实现与架构优化 打造工业级推荐系统4：推荐系统怎么更好的帮助公司挣钱？ 打造工业级推荐系统5：推荐系统冷启动全解析 打造工业级推荐系统6：构建优质的推荐系统服务 打造工业级推荐系统7：怎么评估推荐系统的效果？ 沈国阳：美团推荐系统整体框架与关键工作 一个完整推荐系统的设计实现-以百度关键词搜索推荐为例 推荐系统召回四模型之：全能的FM模型 以youtube的RL论文学习如何在推荐场景应用RL 增强学习在推荐系统有什么最新进展？ 推荐系统陷阱之离线指标计算 最近三年四大顶会深度推荐系统上的18篇论文   计算机视觉   知乎：推荐的计算机视觉项目 目标检测算法之SSD [基于深度学习的目标检测算法：SSD——常见的目标检测算法 从RCNN到SSD，这应该是最全的一份目标检测算 【SSD算法】史上最全代码解析-核心篇 [校招-基础算法]目标检测模型(FasterRCNN和YOLO系列)   网络结构   VGGNet   线上比赛   腾讯广告算法大赛2019 中国大学生程序设计竞赛   算法   数学之美：维特比和维特比算法 同态加密算法简述 怎样成为一名优秀的算法工程师   各大OJ ACM NOIP   洛谷 vijos 杭电 北大poj HDU 4173 Party Location（计算几何，枚举） HDU 5437 Alisha’s Party（优先队列模拟） [ACM进阶之路] 刘汝佳黑书进阶习题 ACM必学知识点清单 Noip知识点总结 NOIP / 省选 /NOI 知识点汇总 安徽省ACM2018问题 合肥工业大学oj 1083 广告牌的困扰 NOIP2019提高组模拟\u0026ndash;拆网线 NOIP历年真题练习-提高组 KDtree浅谈 【空间划分】KDTree Leetcode 春季赛：校园自行车分配 HDU 6521 Party（线段树 + 思维) DP算法分类总结   语音识别   交互式对话技术   自然语言   Github资源 自然语言理解 nlp硬核入门-隐马尔科夫模型 nlp中的预训练语言模型总结(单向模型、BERT系列模型、XLNet) 中文自然语言处理相关的开放任务，数据集, 以及当前最佳结果   人工智能算法   知乎：对xgboost的理解 基于深度学习的广告CTR预估算法 神经网络优化算法：Dropout、梯度消失/爆炸、Adam优化算法，一篇就够了 从GMM和HMM开始说EM算法 图神经网络（Graph Neural Networks，GNN)综述 【强化学习入门 1】从零开始认识强化学习   创业相关   知乎：大学生如何创业 知乎：怎样写创业计划书   大数据相关   DigSci科学数据挖掘大赛 百度推荐引擎及其背后的大数据架构揭秘   数据库相关   MySQL性能优化 高手详解SQL性能优化十条经验 美团的大数据平台架构实践   编程相关   高性能网络编程（一）\u0026mdash;-accept建立连接 性能调优攻略   编译原理相关   Principles of Program Analysis Principles and Techniques of Compilers CS143: Compilers CS243: Program Analysis and Optimization COMP 412：Compiler Construction for Undergraduates  ","permalink":"https://zxcasd848955.github.io/blog/post-9/","tags":["links"],"title":"一些链接"},{"categories":["Programming"],"contents":"Web应用体系架构   Web Client\n Reponse (xml, javascript, vbscript)    Web服务器\n IIS Apache    中间件\n  Tomcat\n  Weblogic\n  Webshper\n     数据库  DB2 MySQL Oracle    ##网站安全常见问题\n 网络层面  拒绝服务, IP欺骗, ARP欺骗, 嗅探   系统层面  软件框架漏洞攻击(Struts2, Openssl), 配置错误   应用层面  代码缺陷(SQl注入, XSS, CSRF) 信息泄露 拒绝服务, CC攻击 钓鱼,业务流程缺陷    ##OWSAP\n OWSAP(Open Web Application Security Project) 是开源非盈利的全球性安全组织,官网\n    OWSAP Top10 -2013     A1 注入   A2 失效的身份认证和会话管理   A3 跨站脚本(XSS)   A4 不安全的直接对象引用   A5 安全配置错误   A6 敏感信息泄露   A7 功能级访问控制缺失   A8 跨站请求伪造   A9 使用已知含有漏洞的组件   A10 未验证的重定向和转发    ##Examples\n###SQL 注入\nSelect * from accounts where username = \u0026#39;admin\u0026#39; and Password = \u0026#39;\u0026#39; or \u0026#39;1\u0026#39; = \u0026#39;1\u0026#39; Select * from users where name = \u0026#39;jsmith\u0026#39;--\u0026#39; And pwd=\u0026#39;a\u0026#39;   严格检查用户输入 : \u0026lt; \u0026gt; * | ` \u0026amp; 4 ！ # （）; { } ../ ..\\ and or script select等 转义用户输入 谨慎使用存储过程 防止错误页面信息泄露 使用安全的API参考ESAPI项目   ###不安全的直接对象引用\nhttp://example.com/online/getnews.asp?item=11   锁定网站服务器所以目录和文件夹，设置访问权限 验证用户输入和URL请求, 拒绝包含./ 或 ../的请求   ###安全配置错误\n  服务器未及时安装补丁 网站未禁止目录浏览功能 安装不需要的服务如FTP 和SMIP   ###CSRF\n  避免URL明文显示操作参数内容 使用同步令牌(Synchronizer Token) 检查请求是否包含令牌及其有效性 检查Referer header拒绝来自非本网站的直接请求   ##编程常见错误\n###整数回绕与溢出\nunsigned int ui; ui = UINT_MAX; ui++; printf(\u0026#34;ui=%dl\\n\u0026#34;, ui); ui = 0; ui--; printf(\u0026#34;ui=%dl\\n\u0026#34;, ui); // sum + 1 \u0026gt; UINT_MAX永远不可能 ###整数赋值错误\nint i=3; unsigned short ui = i; //ui = 65533 // 有符号转为无符号必须验证范围 unsigned int ui = ULONG_MAX; char c = -1; printf(\u0026#34;%d\u0026#34;, c==ui) // 1 //无符号与有符号之间的隐式转换 ###size_t导致的死循环\nsize_t s = sizeof(int); while( --s \u0026gt;= 0){ printf(\u0026#34;%d\u0026#34;, s) }// --s \u0026gt; 0 //size_t 为无符号整型 ###整型提升导致的内存溢出\nchar c1 = \u0026#39;a\u0026#39;; char c2 = \u0026#39;b\u0026#39;; char c3 = c1 + c2; //------------------------ signed char c, c1 = 100, c2 = 3, c3 = 4; c = c1*c2 / c3; //整型参与运算时，若都小于int，则都转换为int, 若不都小于int,则小于int 类型的自动提升为unsigned int ###误用short引起的缓冲区溢出\nvoid test(char *c){ short s = strlen(c);// size_t s = ..  char buf[256]; cout \u0026lt;\u0026lt; \u0026#34;strlen(c)=\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;s =\u0026#34;\u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; if (s \u0026lt; 256){ strcpy(buf); }else{ cout \u0026lt;\u0026lt; \u0026#34;overflow\u0026#34;\u0026lt;\u0026lt;endl; } void main(){ char *c = new char[35000]; memset(c, \u0026#39;c\u0026#39;, 35000); c[35000-1] = \u0026#34;\\0\u0026#34;; test(c); }//strlen(c) = 34999 s = -30537 ###未正确区分标量和数组问题\nObj *obj = new Obj[5];// new Obj(5) delete obj; obj = new Obj(5);// new Obj[5] delete[] obj; ###避免XML注入\n  拒绝服务漏洞 XML注入 XML外部实体注入   ##软件开发安全概述\n 软件生命周期模型\n 瀑布模型 迭代模型 增量模型 快速原型模型 螺旋模型 净室模型    软件安全开发生命周期模型\n SDL 文档丰富，维护更新及时 较多工具支持， 适合大型企业 CLASP 轻量级过程，适合小型企业 SAMM 开放框架，安全知识要求较低 BSIMM 最佳实践参考， 不强制实践 BSI接触点 强调开发安全重点，注重实用方法，上手容易 CMMI 自动的可扩展的框架，持续改进  软件安全属性\n 机密性 完整性 可用性 可追踪性 抗抵赖性  ","permalink":"https://zxcasd848955.github.io/blog/post-7/","tags":["software security"],"title":"软件安全常见问题"},{"categories":["Programming"],"contents":"采用的是apache多子域名部署(当然还有IP和端口) 前提是先在阿里云域名解析添加多个子域名 记录类型为A记录 IP地址为你的阿里云主机IP地址\napache虚拟主机配置\n//Laravel \u0026lt;VirtualHost *:80\u0026gt; ServerName www.cz123.xyz DocumentRoot /var/www/html/blog/public DirectoryIndex index.html index.php \u0026lt;Directory \u0026#34;/var/www/html/blog/public\u0026#34;\u0026gt; Options FollowSymLinks AllowOverride All Order allow,deny allow from all \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; //Laravel \u0026lt;VirtualHost *:80\u0026gt; ServerName aa.cz123.xyz DocumentRoot /var/www/html/college/public DirectoryIndex index.html index.php ErrorLog \u0026#34;/var/www/wwwlogs/webrtc.college.cz123.xyz_error_apache.log\u0026#34; \u0026lt;Directory \u0026#34;/var/www/html/college/public\u0026#34;\u0026gt; Options FollowSymLinks AllowOverride All Order allow,deny allow from all \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; //symfony \u0026lt;VirtualHost *:80\u0026gt; ServerName bb.cz123.xyz DocumentRoot /var/www/html/symfony/web # DirectoryIndex app.php index.html ErrorLog \u0026#34;/var/www/wwwlogs/webrtc.symfony.cz123.xyz_error_apache.log\u0026#34; \u0026lt;Directory \u0026#34;/var/www/html/symfony/web\u0026#34;\u0026gt; Options FollowSymLinks AllowOverride All Order allow,deny allow from all \u0026lt;/Directory\u0026gt; \u0026lt;IfModule mod_rewrite.c\u0026gt; RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$/app.php [QSA,L] \u0026lt;/IfModule\u0026gt; \u0026lt;/VirtualHost\u0026gt; //node eggjs \u0026lt;VirtualHost *:80\u0026gt; ServerName cc.cz123.xyz #DocumentRoot /var/www/html/node # DirectoryIndex index.html index.php ErrorLog \u0026#34;/var/www/wwwlogs/webrtc.node.cz123.xyz_error_apache.log\u0026#34; CustomLog \u0026#34;/var/www/wwwlogs/webrtc.node.cz123.xyz__apache.log\u0026#34; common ProxyRequests off # ProxyPreservehost On \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; //开启apache代理 将所有请求(请求路径为 / )转发到 http://localhost:7001/ //同时还要加载apache的代理模块 //在httpd.conf中 //LoadModule proxy_module modules/mod_proxy.so //LoadModule proxy_connect_module modules/mod_proxy_connect.so //LoadModule proxy_ftp_module modules/mod_proxy_ftp.so //LoadModule proxy_http_module modules/mod_proxy_http.so ProxyPass / http://localhost:7001/ ProxyPassReverse / http://localhost:7001/ \u0026lt;/VirtualHost\u0026gt; 然后修改hosts文件/etc/hosts 添加一行 127.0.0.1: cz123.xyz www.cz123.xyz aa.cz123.xyz bb.cz123.xyz cc.cz123.xyz\n","permalink":"https://zxcasd848955.github.io/blog/post-6/","tags":["apache","sub-domain","web"],"title":"apache deploy many sub-domain sites"}]